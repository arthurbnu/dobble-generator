<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Générateur de carte Dobble</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .dobble-card {
      position: relative;
      border-radius: 50%;
      background: white;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      aspect-ratio: 1;
    }
    .dobble-image {
      position: absolute;
      width: 80px;
      height: 80px;
    }
    
    /* Effet de neige */
    .snowflake {
      position: fixed;
      top: -10px;
      z-index: 9999;
      user-select: none;
      pointer-events: none;
      color: white;
      font-size: 1em;
      animation: fall linear infinite;
    }
    
    @keyframes fall {
      to {
        transform: translateY(100vh);
      }
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen p-6">
  <!-- Conteneur de neige -->
  <div id="snow-container"></div>
  
  <div id="app" class="max-w-2xl mx-auto">
    <h1 class="text-3xl font-bold text-center text-blue-600 mb-6">Générateur de carte Dobble</h1>

    <!-- Upload d'images -->
    <div class="bg-white p-6 rounded-lg shadow mb-6">
      <h2 class="text-xl font-semibold mb-4">Ajoutez vos images (max 10)</h2>
      
      <!-- Sélection depuis la galerie -->
      <div class="mb-4">
        <h3 class="text-lg font-medium mb-2">Sélectionnez depuis la galerie</h3>
        
        <!-- Bouton pour charger les images -->
        <div v-if="availableImages.length === 0" class="mb-4">
          <button
            @click="loadGalleryImages"
            class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          >
            Charger les images de la galerie
          </button>
        </div>
        
        <!-- Select de combinaisons prédéfinies et Tout désélectionner -->
        <div class="mb-3 flex gap-2" v-if="predefinedCombinations.length > 0 || selectedGalleryImages.length > 0">
          <select
            v-if="predefinedCombinations.length > 0"
            @change="selectCombinationFromDropdown"
            class="px-3 py-1 border border-gray-300 rounded text-sm"
          >
            <option value="">Sélectionner une combinaison</option>
            <option
              v-for="(combo, idx) in predefinedCombinations"
              :key="idx"
              :value="idx"
            >
              Combinaison {{ idx + 1 }}
            </option>
          </select>
        </div>
        
        <!-- Images sélectionnées -->
        <div class="mb-3 flex gap-3 items-center" v-if="availableImages.length > 0">
          <div class="text-sm">
            <span class="font-semibold">Images sélectionnées : </span>
            <span v-if="selectedGalleryImages.length === 0" class="text-gray-500">Aucune</span>
            <span v-else class="text-blue-600">
              {{ selectedGalleryImages.map(img => extractImageNumber(img.name)).join(', ') }}
            </span>
          </div>
          <button
            v-if="selectedGalleryImages.length > 0"
            @click="deselectAll"
            class="bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700"
          >
            Tout désélectionner
          </button>
        </div>
        
        <div v-if="availableImages.length > 0" class="grid grid-cols-8 gap-4 max-h-60 overflow-y-auto border rounded p-2">
          <div
            v-for="(imgObj, index) in availableImages"
            :key="index"
            @click="toggleImageSelection(imgObj)"
            class="cursor-pointer border-2 rounded p-1 hover:border-blue-500 transition flex flex-col items-center"
            :class="{ 'border-blue-500 bg-blue-50': isImageSelected(imgObj), 'border-gray-300': !isImageSelected(imgObj) }"
          >
            <img :src="imgObj.url" :alt="imgObj.name" class="w-12 h-12 object-contain">
            <p class="text-xs text-center mt-1 truncate w-full font-semibold" :title="imgObj.name">{{ extractImageNumber(imgObj.name) }}</p>
          </div>
        </div>
        <p class="text-sm text-gray-500 mt-2">
          Cliquez sur les images pour les sélectionner ({{ selectedGalleryImages.length }}/10)
        </p>
      </div>

      <!-- Upload personnalisé -->
      <div class="mb-4">
        <h3 class="text-lg font-medium mb-2">Ou uploadez vos propres images</h3>
        <input
          type="file"
          @change="handleFileUpload"
          accept="image/*"
          multiple
          class="block w-full text-sm text-gray-500
            file:mr-4 file:py-2 file:px-4
            file:rounded-md file:border-0
            file:text-sm file:font-semibold
            file:bg-blue-50 file:text-blue-700
            hover:file:bg-blue-100"
        />
      </div>
      
      <p class="text-sm text-gray-500 font-semibold">
        Total: {{ uploadedImages.length }}/10 images
      </p>
      
      <!-- Sélecteur d'échelle -->
      <div class="mt-4">
        <label class="block text-sm font-medium mb-2">Échelle de la carte (en cm)</label>
        <select v-model.number="cardScale" class="block w-full px-3 py-2 border border-gray-300 rounded-md">
          <option value="5">5 cm</option>
          <option value="7.5">7.5 cm</option>
          <option value="10">10 cm</option>
          <option value="13">13 cm</option>
          <option value="15">15 cm</option>
        </select>
      </div>

      <!-- Checkbox pour les rotations -->
      <div class="mt-4 flex items-center">
        <input type="checkbox" v-model="enableRotations" id="enableRotations" class="w-4 h-4">
        <label for="enableRotations" class="ml-2 text-sm font-medium">Activer les rotations aléatoires</label>
      </div>
    </div>

    <!-- Aperçu de la carte Dobble -->
    <div class="flex justify-center mb-6">
      <div class="dobble-card" :style="{ width: cardScale * 40 + 'px', height: cardScale * 40 + 'px' }">
        <div
          v-for="(index, position) in (shuffledIndices.length > 0 ? shuffledIndices : Array.from({length: uploadedImages.length}, (_, i) => i))"
          :key="position"
          class="dobble-image"
          :style="calculatePosition(position)"
        >
          <img :src="uploadedImages[index].url" alt="Image Dobble" class="w-full h-full" />
        </div>
      </div>
    </div>

    <!-- Boutons d'action -->
    <div class="flex justify-center gap-4">
      <button
        @click="regenerateCard"
        :disabled="uploadedImages.length < 2"
        class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 disabled:opacity-50"
      >
        Régénérer la carte
      </button>
      <button
        @click="downloadCard"
        :disabled="uploadedImages.length < 2"
        class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50"
      >
        Télécharger la carte
      </button>
    </div>
  </div>

  <script>
    const { createApp, ref, watch } = Vue;

    createApp({
      setup() {



/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
/////////////////////////////////


const text2 = `
1 : {1,3,4,5,6,7,8,9,10,11}
2 : {11,12,21,30,39,48,57,66,75,84}
3 : {11,13,22,31,40,49,58,67,76,85}
4 : {11,17,26,35,44,53,62,71,80,89}
5 : {11,16,25,34,43,52,61,70,79,88}
6 : {11,15,24,33,42,51,60,69,78,87}
7 : {11,14,23,32,41,50,59,68,77,86}
8 : {11,19,28,37,46,55,64,73,82,91}
9 : {11,18,27,36,45,54,63,72,81,90}
10 : {1,2,12,13,14,15,16,17,18,19}
11 : {2,3,21,31,41,51,61,71,81,91}
12 : {2,4,22,30,44,55,63,68,79,87}
13 : {2,8,26,32,39,54,60,67,82,88}
14 : {2,7,25,36,46,48,59,69,80,85}
15 : {2,6,24,37,43,53,57,72,76,86}
16 : {2,5,23,35,40,52,64,66,78,90}
17 : {2,10,28,33,45,50,58,70,75,89}
18 : {2,9,27,34,42,49,62,73,77,84}
19 : {1,20,21,22,23,24,25,26,27,28}
20 : {3,13,20,30,43,50,60,73,80,90}
21 : {4,12,20,31,45,53,64,69,77,88}
22 : {8,14,20,35,42,48,63,70,76,91}
23 : {7,18,20,34,41,55,57,67,78,89}
24 : {6,19,20,33,39,52,62,68,81,85}
25 : {5,17,20,32,46,49,61,72,75,87}
26 : {10,15,20,37,40,54,59,71,79,84}
27 : {9,16,20,36,44,51,58,66,82,86}
28 : {1,29,30,31,32,33,34,35,36,37}
29 : {3,12,22,29,42,52,59,72,82,89}
30 : {4,13,21,29,46,54,62,70,78,86}
31 : {8,17,23,29,45,51,57,73,79,85}
32 : {7,16,27,29,39,50,64,71,76,87}
33 : {6,15,28,29,44,48,61,67,77,90}
34 : {5,14,26,29,43,55,58,69,81,84}
35 : {10,19,24,29,41,49,63,66,80,88}
36 : {9,18,25,29,40,53,60,68,75,91}
37 : {1,39,40,41,42,43,44,45,46,65}
38 : {3,17,27,37,48,58,65,68,78,88}
39 : {4,14,25,33,49,57,65,71,82,90}
40 : {8,13,28,34,53,59,65,66,81,87}
41 : {7,15,26,31,52,63,65,73,75,86}
42 : {6,18,22,32,51,64,65,70,80,84}
43 : {5,12,24,36,50,62,65,67,79,91}
44 : {10,16,21,35,55,60,65,72,77,85}
45 : {9,19,23,30,54,61,65,69,76,89}
46 : {1,48,49,50,51,52,53,54,55,56}
47 : {3,19,26,36,40,56,57,70,77,87}
48 : {4,15,23,34,39,56,58,72,80,91}
49 : {8,16,22,37,41,56,62,69,75,90}
50 : {7,13,24,35,45,56,61,68,82,84}
51 : {6,14,27,31,46,56,60,66,79,89}
52 : {5,18,21,33,44,56,59,73,76,88}
53 : {10,17,25,30,42,56,64,67,81,86}
54 : {9,12,28,32,43,56,63,71,78,85}
55 : {1,47,57,58,59,60,61,62,63,64}
56 : {3,18,28,35,39,47,49,69,79,86}
57 : {4,16,24,32,40,47,48,73,81,89}
58 : {8,19,25,31,44,47,50,72,78,84}
59 : {7,17,22,33,43,47,54,66,77,91}
60 : {6,13,23,36,42,47,55,71,75,88}
61 : {5,15,27,30,41,47,53,70,82,85}
62 : {10,12,26,34,46,47,51,68,76,90}
63 : {9,14,21,37,45,47,52,67,80,87}
64 : {1,38,66,67,68,69,70,71,72,73}
65 : {3,14,24,34,38,44,54,64,75,85}
66 : {4,17,28,36,38,41,52,60,76,84}
67 : {8,12,27,33,38,40,55,61,80,86}
68 : {7,19,21,32,38,42,53,58,79,90}
69 : {6,16,26,30,38,45,49,59,78,91}
70 : {5,13,25,37,38,39,51,63,77,89}
71 : {10,18,23,31,38,43,48,62,82,87}
72 : {9,15,22,35,38,46,50,57,81,88}
73 : {1,75,76,77,78,79,80,81,82,83}
82 : {1,74,84,85,86,87,88,89,90,91}
83 : {3,15,25,32,45,55,62,66,74,76}
84 : {4,19,27,35,43,51,59,67,74,75}
85 : {8,18,24,30,46,52,58,71,74,77}
86 : {7,12,23,37,44,49,60,70,74,81}
87 : {6,17,21,34,40,50,63,69,74,82}
88 : {5,16,28,31,42,54,57,68,74,80}
89 : {10,14,22,36,39,53,61,73,74,78}
90 : {9,13,26,33,41,48,64,72,74,79}
83 : {2,11,20,29,38,47,56,65,74,83}
84 : {3,16,23,33,46,53,63,67,83,84}
85 : {4,18,26,37,42,50,61,66,83,85}
86 : {5,19,22,34,45,48,60,71,83,86}
87 : {6,12,25,35,41,54,58,73,83,87}
88 : {7,14,28,30,40,51,62,72,83,88}`


const combinations = text2.trim().split('\n').map(line => {
    const match = line.match(/{([\d,\s]+)}/);
    return match ? match[1].split(',').map(num => parseInt(num.trim(), 10)) : [];
});

//////////////////////
//////////////////////
//////////////////////
//////////////////////
//////////////////////


        const uploadedImages = ref([]);
        const cardScale = ref(10); // Valeur par défaut: 10 cm
        const shuffledIndices = ref([]);
        const enableRotations = ref(true); // Activer les rotations par défaut
        
        // Images disponibles depuis l'upload (objets avec name et url)
        const availableImages = ref([]);
        const selectedGalleryImages = ref([]);
        const predefinedCombinations = ref([]);

        // Fonction pour charger les 91 images du dossier images/
        const loadGalleryImages = () => {
          for (let i = 1; i <= 91; i++) {
            availableImages.value.push({
              name: `DFIm${i}.png`,
              url: `images/DFIm${i}.png`
            });
          }
          generateCombinations();
        };

        // Watcher pour forcer la recalculation quand on change les rotations
        watch(enableRotations, () => {
          // Forcer Vue à recalculer les positions
          uploadedImages.value = [...uploadedImages.value];
        });

        const shuffleImages = () => {
          // Créer un tableau d'indices
          const indices = Array.from({ length: uploadedImages.value.length }, (_, i) => i);
          // Mélanger avec l'algorithme Fisher-Yates
          for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
          }
          shuffledIndices.value = indices;
        };

        const toggleImageSelection = (imgObj) => {
          const index = selectedGalleryImages.value.findIndex(img => img.url === imgObj.url);
          if (index > -1) {
            // Déselectionner
            selectedGalleryImages.value.splice(index, 1);
          } else {
            // Sélectionner si on n'a pas atteint la limite
            if (selectedGalleryImages.value.length < 10) {
              selectedGalleryImages.value.push(imgObj);
            } else {
              alert("Maximum 10 images autorisées.");
            }
          }
          updateUploadedImages();
        };

        const isImageSelected = (imgObj) => {
          return selectedGalleryImages.value.some(img => img.url === imgObj.url);
        };

        const updateUploadedImages = () => {
          // Combine les images de la galerie et celles uploadées
          uploadedImages.value = [...selectedGalleryImages.value];
          shuffledIndices.value = [];
          shuffleImages();
        };

        const generateCombinations = () => {
          // Parser les combinaisons du texte text2
          predefinedCombinations.value = [];
          
          const lines = text2.split('\n').filter(line => line.trim());
          lines.forEach(line => {
            const match = line.match(/\d+\s*:\s*{([\d,\s]+)}/);
            if (match) {
              const numbers = match[1].split(',').map(n => parseInt(n.trim(), 10));
              // Créer un array d'objets image pour cette combinaison
              const combo = numbers.map(num => {
                return availableImages.value.find(img => img.name === `DFIm${num}.png`);
              }).filter(img => img); // Filtrer les undefined
              
              if (combo.length === 10) {
                predefinedCombinations.value.push(combo);
              }
            }
          });
        };

        const selectCombination = (combo) => {
          selectedGalleryImages.value = [...combo];
          updateUploadedImages();
        };

        const selectCombinationFromDropdown = (event) => {
          const idx = parseInt(event.target.value, 10);
          if (!isNaN(idx) && predefinedCombinations.value[idx]) {
            selectCombination(predefinedCombinations.value[idx]);
            event.target.value = ''; // Réinitialiser le select
          }
        };

        const deselectAll = () => {
          selectedGalleryImages.value = [];
          uploadedImages.value = [];
          shuffledIndices.value = [];
        };

        const extractImageNumber = (filename) => {
          // Extrait le numéro du nom de fichier (ex: DFIm91.png -> 91)
          const match = filename.match(/\d+/);
          return match ? match[0] : filename;
        };

        const handleFileUpload = (event) => {
          const files = Array.from(event.target.files);
          files.forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
              const dataUrl = e.target.result;
              availableImages.value.push({
                name: file.name,
                url: dataUrl
              });
              generateCombinations();
            };
            reader.readAsDataURL(file);
          });
        };

        const calculatePosition = (index) => {
          const totalImages = uploadedImages.value.length;
          const cardSize = cardScale.value * 40; // Conversion cm en pixels (1cm = 40px)
          const imageSize = cardSize * 0.25; // 25% de la taille de la carte
          let angle, radius, x, y;
          
          // Si on a 1 image, la mettre au centre
          if (totalImages === 1) {
            x = cardSize / 2 - imageSize / 2;
            y = cardSize / 2 - imageSize / 2;
          }
          // Pour 2+ images : 1 au centre, les autres en cercle
          else {
            if (index === 0) {
              // Image au centre
              x = cardSize / 2 - imageSize / 2;
              y = cardSize / 2 - imageSize / 2;
            } else {
              // Images en cercle, plus proches du bord
              const indexEnCercle = index - 1;
              const imagesEnCercle = totalImages - 1;
              angle = (indexEnCercle / imagesEnCercle) * 2 * Math.PI;
              radius = cardSize * 0.35; // Rapproché du bord (0.35 au lieu de 0.275)
              x = cardSize / 2 + radius * Math.cos(angle) - imageSize / 2;
              y = cardSize / 2 + radius * Math.sin(angle) - imageSize / 2;
            }
          }
          
          // Rotation aléatoire entre 0 et 360 degrés (ou 0 si désactivée)
          const rotation = enableRotations.value ? Math.random() * 360 : 0;
          
          // Variation de taille entre 60 et 100%
          const scale = 0.6 + Math.random() * 0.4;
          
          return {
            left: `${x}px`,
            top: `${y}px`,
            width: `${imageSize}px`,
            height: `${imageSize}px`,
            transform: `rotate(${rotation}deg) scale(${scale})`,
            transformOrigin: 'center center',
          };
        };

        const regenerateCard = () => {
          // Mélanger l'ordre des images et forcer Vue à recalculer les positions
          shuffleImages();
          uploadedImages.value = [...uploadedImages.value];
        };

        const downloadCard = () => {
          const DPI = 300; // 300 DPI pour une bonne qualité d'impression
          const cardSize = cardScale.value * DPI / 2.54; // Conversion cm en pixels @ 300 DPI
          const imageSize = cardSize * 0.25; // 25% de la taille de la carte
          
          const canvas = document.createElement('canvas');
          canvas.width = cardSize;
          canvas.height = cardSize;
          const ctx = canvas.getContext('2d');

          // Fond blanc circulaire
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.arc(cardSize / 2, cardSize / 2, cardSize / 2, 0, 2 * Math.PI);
          ctx.fill();
          
          // Créer un masque circulaire pour les images
          ctx.beginPath();
          ctx.arc(cardSize / 2, cardSize / 2, cardSize / 2, 0, 2 * Math.PI);
          ctx.clip();

          // Ajout des images
          const imageElements = [];
          const indicesToUse = shuffledIndices.value.length > 0 ? shuffledIndices.value : Array.from({ length: uploadedImages.value.length }, (_, i) => i);
          
          indicesToUse.forEach((imgIndex, position) => {
            const img = uploadedImages.value[imgIndex];
            const imgEl = new Image();
            imgEl.crossOrigin = "anonymous";
            imgEl.src = img.url;
            imgEl.onload = () => {
              const totalImages = uploadedImages.value.length;
              let x, y, angle, radius;
              
              // Même logique de positionnement
              if (totalImages === 1) {
                x = cardSize / 2;
                y = cardSize / 2;
              } else {
                if (position === 0) {
                  x = cardSize / 2;
                  y = cardSize / 2;
                } else {
                  const indexEnCercle = position - 1;
                  const imagesEnCercle = totalImages - 1;
                  angle = (indexEnCercle / imagesEnCercle) * 2 * Math.PI;
                  radius = cardSize * 0.35; // Rapproché du bord
                  x = cardSize / 2 + radius * Math.cos(angle);
                  y = cardSize / 2 + radius * Math.sin(angle);
                }
              }
              
              // Rotation aléatoire entre 0 et 360 degrés (ou 0 si désactivée)
              const rotation = enableRotations.value ? Math.random() * 360 * (Math.PI / 180) : 0;
              
              // Variation de taille entre 60 et 100%
              const scale = 0.6 + Math.random() * 0.4;
              
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rotation);
              ctx.scale(scale, scale);
              ctx.drawImage(imgEl, -imageSize / 2, -imageSize / 2, imageSize, imageSize);
              ctx.restore();
              
              imageElements.push(position);
              
              if (imageElements.length === uploadedImages.value.length) {
                canvas.toBlob((blob) => {
                  const url = URL.createObjectURL(blob);
                  const link = document.createElement('a');
                  link.download = `dobble-card-${cardScale.value}cm.png`;
                  link.href = url;
                  link.click();
                  URL.revokeObjectURL(url);
                });
              }
            };
          });
        };

        return {
          uploadedImages,
          cardScale,
          shuffledIndices,
          enableRotations,
          availableImages,
          selectedGalleryImages,
          predefinedCombinations,
          handleFileUpload,
          calculatePosition,
          shuffleImages,
          regenerateCard,
          downloadCard,
          toggleImageSelection,
          isImageSelected,
          selectCombination,
          selectCombinationFromDropdown,
          deselectAll,
          loadGalleryImages,
          extractImageNumber,
        };
      }
    }).mount('#app');

    // Créer l'effet de neige
    function createSnowflakes() {
      const container = document.getElementById('snow-container');
      const snowflakeCount = 50;
      
      for (let i = 0; i < snowflakeCount; i++) {
        const snowflake = document.createElement('div');
        snowflake.className = 'snowflake';
        snowflake.innerHTML = '❄';
        snowflake.style.left = Math.random() * 100 + '%';
        snowflake.style.animationDuration = (Math.random() * 3 + 2) + 's';
        snowflake.style.animationDelay = Math.random() * 5 + 's';
        snowflake.style.fontSize = (Math.random() * 10 + 10) + 'px';
        snowflake.style.opacity = Math.random();
        container.appendChild(snowflake);
      }
    }
    
    // Lancer l'effet de neige au chargement
    createSnowflakes();
  </script>
</body>
</html>
